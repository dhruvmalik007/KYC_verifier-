---
eip: <to be assigned>
title:   Verification/Issuance of onchain KYC using ZKP. 
description: Interface for on-chain validations of identitiy using ZK proofs.
author: Yu Liu (@yuliu-debond). 
discussions-to: TBD
status: Draft
type: Standards Track
category: ERC
created: 2022-10-18
requires: 20, 721, 1155, 3643, 3475, 3545, 2980.

---

## Abstract

- This EIP Provides a defined interface for KYC verification (either EOA or wallet contract) while keeping  verification conditions stored fully on-chain along with their associated metadata.

- This EIP also provides interface for implementing ZKP based verification protocols with off-chain data. user only has to provide their ownershipAddress along with the tokenId associated with their SBT certificate.

## Motivation

On-chain certification and verification schemes are becoming indispensable across DeFi as well as other web3 Dapp use cases as it's needed by the institutions for due diligence of actors in order to access services via smart contracts (like whitelisting the users  which are fulfilling certain regulations concerning identity, minimum amount of the users etc).


This created the necessity of building on-chain verification of the addresses for token transfers (like stablecoin providers checking for the blacklisted entities for the destination address, limited utility tokens for a DAO community, etc).


But given the nature of verification needed for compliance transfers is being more privacy driven, doing matching of metadata consisting of PII is discouraged. and in order to solve this issue, signature encryption based digital verification standard like [EIP-1271](./eip-1271.md) are also effective but are less efficient wrt gas costs and still need help of external oracle to validate the verification conditions, thus creating problems.

Also current standards in the space  of compliance token callers like: [EIP-3643](./eip-3643.md) for security compliant token transfers,[EIP-2980](./eip-2980.md) as extension of ERC20 according to swiss legal compliance etc are very application specific and dont take into consideration about the different jurisdictions or policies in the space. 

thus we came up with the standard interface that allows developers to: 
    - Define the KYC validation rules using algebraic conditions fully onchain (that can be interpreted by ZKP as circuits).
    - defining the certification issuance / verification of the wallet address onchain.

## Specification: 

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

**Definition**

- SBT: Soul Bound Tokens, these are non-fungible and non-transferrable tokens that are used for defining the identity of the users. they are Defined by standard [eip-5192](./eip-5192.md).

- SBT Certificates: SBT that represent the  ownerships of ID signatures corresponding to the requirements defined in `function standardRequirement()`.


**Functions**

```solidity
pragma solidity ^0.8.0;
   
     // getter function 
    /// @notice validates if the address `verifying` is issued the KYC based on SBT identified by its tokenId `SBTID`
    /// @dev it MUST be Defining the logic corresponding to all the current possible requirements Definition.
    /// @dev Logic given here MUST be one of  algebraic set operations like("⊄", "⊂", "<", "<=", "==", "!=", ">=", ">").
    /// @param verifying is the  EOA address that wants to validate the SBT issued to it by the KYC. 
    /// @param SBTID is the Id of the SBT of which the user is the claimer.
    /// @return true if the assertion is valid, else false
    /**
    example ifVerified(0xfoo, 1) => true will mean that 0xfoo is the holder of the SBT identity token DeFined by tokenId of the given collection. 
    */
    function ifVerified(address verifying, uint256 SBTID) external view returns (bool);

    /// @notice getter function to fetch the onchain identification logic for the given identity holder.
    /// @dev it MUST not be DeFined for address(0). 
    /// @param SBTID is the Id of the SBT on which the user is the claimer.
    /// @return the struct array of all the descriptions of condition metadata that is DeFined by the administrator.
    /**
    ex: standardRequirement(1) => {
    { "title":"adult",
        "type": "uint",
        "description": "If this person is more than 18 years old",
        },
       "logic": ">=",
    "value":"18"  
}
Defines the condition encoded for the identity index 1, DeFining the identity condition that the holder must be more than 18 years old.
    */
    function standardRequirement(uint256 SBTID) external view returns (Requirement[] memory);

    // setter functions
    /// @notice function for setting the requirement logic (DeFined by Requirements metadata) details for the given identity token DeFined by SBTID.
    /// @devlogic given here MUST be one of ("⊄", "⊂", "<", "<=", "==", "!=", ">=",">")
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to DeFine the Requirements.
    /// @param `requirements` is the struct array of all the descriptions of condition metadata that the administrator defines. check the metadata section for more information.
    function changeStandardRequirement(uint256 SBTID, Requirement[] memory requirements) external returns (bool);
    
    /// @notice function which uses the ZKProof protocol to validate the identity based on the given verification protocol. (STARKS, SNARKS ...)
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to DeFine the Requirements.
    /// @param certifying is the address that needs to be proven as the owner of the SBT DeFined by the tokenID.
    /// @param `requirement` is the struct array of all the descriptions of condition metadata defined by the administrator. check the metadata section for more information.
    function certify(address certifying, uint256 SBTID) external returns (bool);

    /// @notice function to revoke the SBT-based identity certificate (identified by `id` address) for address `certifying`.
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to DeFine the Requirements.
    /// @param certifying is the address that needs to be proven as the owner of the SBT DeFined by the tokenID.
    /// @param `requirement` is the struct array of all the descriptions of condition metadata Defined by the administrator. check the metadata section for more information.
    function revoke(address certifying, uint256 SBTID) external returns (bool);
```

**Events**

```solidity
pragma solidity ^0.8.0;   
/** 
    * standardChanged
    * @notice standardChanged MUST be triggered when requirements are changed. 
    * @dev standardChanged MUST also be triggered for the creation of a new SBTID.
    */
    event standardChanged(uint256 SBTID, Requirement[]);   
    
    /** 
    * certified
    * @notice certified MUST be triggered when SBT certificate is given to the certifiying address. 
    */
    event certified(address certifying, uint256 SBTID);
    
    /** 
    * revoked
    * @notice revoked MUST be triggered when SBT certificate is revoked. 
    */
    event revoked(address certifying, uint256 SBTID);
```

## Rationale

**Metadata structure**: 

```solidity
    /**
     * @dev metadata and Values structure of the Metadata, cited from [EIP-3475](./eip-3475.md) 
     */     
    struct Metadata {
        string title;
        string _type;
        string description;
    }
    
    /**
     * @dev Values here can be read and wrote by smartcontract and front-end, cited from [EIP-3475](./eip-3475.md) 
     */   
    struct Values { 
        string stringValue;
        uint uintValue;
        address addressValue;
        bool boolValue;
    }
```

**Requirement structure**:

```solidity

    /**
     * @dev structure that DeFines the parameters for specific requiremet of the SBT certificate
     * @notice this structure is used for the verification process, it chontains the metadata, logic and expectation
     * @logic given here MUST be one of ("⊄", "⊂", "<", "<=", "==", "!=", ">=",">")
     ex: standardRequirement => {
    { "title":"adult",
        "type": "uint",
        "description": "If this person is more than 18 years old",
        },
       "logic": ">=",
    "value":"18"  
	}
	Defines the condition encoded for the identity index 1, DeFining the identity condition that holder must be more than 18 years old.
    */
	
    struct Requirement {
        Metadata metadata;
        string logic;
        Values expectation;
    }

```

## Backwards Compatibility

Any existing fungible/non fungible asset contract standards (eip-20, 721, 1155, 3475 etc.) can use this interface to access-control the execution of certain functions only by the address holding the right SBT certificates.

**Note that the this standard interface is also compatible with [EIP-20](./eip-20.md), [EIP-721](./eip-721.md) and [EIP-3475](./eip-3475.md). 

However, an update is needed to amend the KYC modifier in case the conditions of validating the KYC of the address is changed.

## Test Cases

Test-case for the minimal reference implementation is [here](./test.sol). Use the Truffle box to compile and test the contracts.

## Reference Implementation

The [interface](./interfaces/IERC6595.sol) contains two separated implementations:

- [verification_modifier](../SBT_certification.sol)
  - modifier that needs to be implemented into the functions which need KYC certification for deployment.

- [SBT_certification](../verification_modifier.sol)
   - functions required in the SBT certificate contract to assign to another address.

## Security Considerations

1. Writing functions interfaces (i.e `changeStandardRequirement()`, `certify()` and `revoke()`)  SHOULD be executed by admin roles in the SBT certificate contract as the getter functions (verify()) depends on the availablity of the necessary metadata to be immutable by any other non-admin entity.

2. The modifiers SHOULD not be deployed for the verifier contract that is upgradable (either via proxy patterns defined by [EIP-1167](./eip-1167.md), [EIP-1967](./eip-1967.md)). if the requirement is deemed important, there needs to be appropriate roles (usually by admin) in order to insure that modifier logic doesnt get corrupted or creates the unintended backdoor.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
